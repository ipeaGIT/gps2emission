---
title: "Introduction to GTFS2EMIS"
output: github_document
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
### 1) GTFS data

The estimation of hot exhaust emissions from GTFS data uses functions from `gtfs2gps` package, as shown in the reproducible example below. The main information used from this data is `speed` and distance `dist`.

```{r, message = FALSE}
library(gtfs2gps)
library(data.table)
library(gtfs2emis)
library(vein)
library(magrittr)
poa <- gtfs2gps::read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))
poa <- gtfs2gps::gtfs2gps(poa)
```
Input data dimensions can be simplified by using line segments (`linestring` geometry type) instead of `points`, since the emissions varies according to distance and speed. 

```{r}
poa_gpslines <- gtfs2gps::gps_as_sflinestring(poa) %>% data.table::as.data.table()
object.size(poa) %>% format("Mb")
dim(poa)
object.size(poa_gpslines) %>% format("Mb")
dim(poa_gpslines)
```

### 2) Fleet data

There are different types of fleet data that can be used for estimating emissions. 

#### Regional data

Data often obtained from registry of vehicles in local agencies of transportation, which generally does not relate a certain vehicle category (age and/or technology) to a specific route or shape in the GTFS. 
In this situation, only a distribution of fleet is known, so the inputs in each shape or route is given by a probability of distribution. It considers that, on average, all vehicles has the same chance to circulate in each route or shape. 

```{r}
total_fleet <- data.table::data.table("2005"=1,"2010"=61,"2011"=50,"2012"=1,
                                     "2014"=45,"2015"=18,"2017"=62,"2018"=27,"2019"=31)
```
with probability of distribution based on frequency of `total_fleet`
```{r}
 veh_distri <- as.numeric( total_fleet[1,]/sum(total_fleet[1,]) )
 veh_distri
 sum(veh_distri)
```

#### Detailed data

Used when the category of the vehicle is known for each route/shape of GTFS. 

```{r}
det_fleet <- data.table::data.table("shape_id" = unique(poa$shapes$shape_id),
                                    "bus_age" = c("2010","2011","2012","2013"),
                                    "bus_fuel" = "Diesel")
```

### 3) Emission factor

Emission factors functions is expressed in units `g/km`, and can be speed-dependent according to emission factor data source. The avaliable emissions factors are:

#### European emission factors for buses categories

Pollutants (g/km): CO, NOx, HC, PM, CH4, NMHC, CO2, SO2, Pb, FC ,NO,NO2.

```{r }

euro_stage = c("II","IV","IV","V","V","V","V","V","V") # euro equivalent for brazilian fleet by years  
EF_europe <- ef_europe(vel = units::set_units(poa_gpslines$speed,'km/h'),
                       veh_type = "Urban Buses Standard 15 - 18 t",
                       tech = "SCR",
                       euro = euro_stage,
                       pol = c("CO","PM"),aggregate = TRUE,
                       veh = veh_distri)
head(EF_europe)
```

#### United States emission factors for buses categories

Pollutants (g/km): CO, NOx, Hydrocarbons as TOG (total organic gases), ROG (reactive organic gases), THC, CH4, PM10, PM2.5, SOx, CO2, N2O and CH4.

```{r}
EF_emfac <- gtfs2emis::ef_emfac(pol = c("CO","PM10"),calendar_year = "2019",
                                model_year = colnames(total_fleet),
                                speed = units::set_units(poa_gpslines$speed,'km/h'),
                                veh = veh_distri,aggregate = TRUE,fuel = "Diesel")
head(EF_emfac,2)
```

#### Brazil emission factors for buses

Pollutants: CO, HC, NMHC, CH4, NOx, CO2,RCHO, ETOH, PM, N2O, KML, FC, NO2, NO, gD/KWH, gCO2/KWH, RCHO, CO_0km, HC_0km, NMHC_0km, NOx_0km, NO2_0km ,NO_0km, RCHO_0km and ETOH_0km, FS (fuel sales) (g/km).
Obtained from `vein` package.
 
```{r}
years <- c("2005","2010","2011","2012","2014","2015","2017","2018")

EF_brazil <- lapply(c("CO","PM"),function(j){
  temp_ef_br <- sapply(seq_along(years),function(i){# i = colnames(total_fleet)[1]
    vein::ef_cetesb(p = j,veh = "BUS_URBAN_D",year = years[i],agemax = 1) * veh_distri[i]
  }) %>% units::set_units("g/km") %>% sum()
  return(temp_ef_br)
})
names(EF_brazil) <- paste0(c("CO","PM"),"_avg")
EF_brazil
```

### 4) Emission 

Emissions are estimated as a product between distance (units `km`) with emission factor (units `g/km`).


#### Using different emission factors

```{r}
# USA
emi_usa <- gtfs2emis::emis(veh = 1,dist = units::set_units(poa_gpslines$dist,'km'),ef = EF_emfac)
unique_names <- paste0("USA_",names(emi_usa))
poa_gpslines[,(unique_names) := emi_usa]

# EUROPE
emi_europe <- gtfs2emis::emis(veh = 1,dist = units::set_units(poa_gpslines$dist,'km'),ef = EF_europe)
unique_names <- paste0("Europe_",names(emi_europe))
poa_gpslines[,(unique_names) := emi_europe]

# BRAZIL (not speed dependent emission factor)
unique_names <- paste0("Brazil_",names(EF_brazil))
emi_brazil <- gtfs2emis::emis(veh = 1,dist = units::set_units(poa_gpslines$dist,'km'),ef = EF_brazil)
poa_gpslines[,(unique_names) := emi_brazil]
```

### 5) Post-processing emissions


#### Hour time stamp
```{r}
hour_post <- gtfs2emis::emis_post(emi = poa_gpslines$USA_CO_avg,
                                  time = "hour",
                                  time_dt = poa_gpslines$departure_time)
library(ggplot2)
ggplot() + 
  geom_bar(data = hour_post,aes(x = time,y = as.numeric(x)),stat = "identity")
```

#### Hour-minute time stamp
```{r}
hour_post <- gtfs2emis::emis_post(emi = poa_gpslines$USA_CO_avg,
                                  time = "hour-minute",
                                  time_dt = poa_gpslines$departure_time)
ggplot() + 
  geom_bar(data = hour_post,aes(x = as.ITime(time),y = as.numeric(x)),stat = "identity")
```

#### Spatially

Make grid for visualize emissions
```{r}
grid_gps <- vein::make_grid(spobj = poa_gpslines,width =  0.25/102.47) #500 mts
plot(grid_gps["id"])
```

Intersection operation

```{r}
poa_sf <- sf::st_as_sf(poa_gpslines)
pol_gps <- vein::emis_grid(spobj = poa_sf["USA_CO_avg"],g = grid_gps)
pol_gps <- pol_gps[as.numeric(pol_gps$USA_CO_avg) > 0,]
plot(pol_gps["USA_CO_avg"])
```


