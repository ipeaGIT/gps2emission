---
title: 'Introduction to gtfs2emis'
author: "Joao Bazzo, Rafael H. M. Pereira, Pedro R. Andrade"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
abstract: "Package `gtfs2emis` generates emission estimates for public transport networks based on GTFS data."
urlcolor: blue
vignette: |
  %\VignetteIndexEntry{Introduction to gtfs2emis} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---






---
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>")
```

# Introduction

The package `gtfs2emis` estimates hot exhaust emissions for public transport systems at high spatial and temporal resolutions based on GTFS data. This vignette introduces the main functions of the package. Here are the following packages we will use:

```{r, message = FALSE}
library(gtfs2emis)
library(magrittr)
library(ggplot2)
```

# GTFS data

To estimate emissions from GTFS data, we need first to compute `speed` and distance (`dist`) of each trip between pairs of public transport stops/stations.
This information is created when we convert GTFS data to GPS-like
records, using `gtfs2gps::gtfs2gps()`. The example below uses a sample of the GTFS data from the city of Porto Alegre, in Brazil. In this example we will only process the trips of two `shape_id`s to speedup processing time.

```{r, message = FALSE}
poa <- gtfs2gps::read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps")) 
poa_subset <- poa %>% gtfs2gps::filter_single_trip()
poa_gps <- gtfs2gps::gtfs2gps(poa)

# the ouput is a data.table, like this
head(poa_gps)
```

The GPS-like data can be converted into line segments (`linestring`). This conversion breaks the trips into separate segments between consecutive pairs of stops. This will give us a much smaller data set to work on. It also allows to capture the spatial-temporal variation of speeds and emission levels. 


```{r}
poa_gpslines <- gtfs2gps::gps_as_sflinestring(poa_gps) 
dim(poa_gpslines)

# the bus routes look like this:
plot(poa_gpslines['speed'])
```

We will also update units of measurement of the attributes in our data.

*This means that each line is a bus?*

```{r}
poa_gpslines$dist <- units::set_units(poa_gpslines$dist, "km")

# The data shows the average speed and distance between pairs of stops
head(poa_gpslines)
```

# Fleet data

To compute emission estimates, we need some basic information on the age and technology of the public transport fleet. The user can input fleet data organized in two different ways. We call them _regional data_ and _detailed data_.

## Regional fleet data

Regional fleet data input is a simple `data.frame` with information on the **relative composition of the fleet in terms of age and technology**. For many cities, this is the only data from registry of vehicles made available by local transport agencies. In this typical situation, there is no information on which vehicles (age and/or technology) are assigned to specific routes in the GTFS. In this case, the package `gtfs2emis` considers that, on average, all vehicles have the same probability to operate on every route of the transport network.
Here is an example of how a _regional fleet data_ looks like:

```{r}
total_fleet <- data.table::data.table(year = c(2005, 2010:2012, 2014:2015, 2017:2019),
                                      bus = c(1, 61, 50, 1, 45, 18, 62, 27, 31),
                                      veh_type_euro = "Ubus Std 15 - 18 t",
                                      euro_stage = c("II", "IV", "IV", rep("V", 6)))

total_fleet[,fleet_composition := bus / sum(bus)]

# The input data looks like this
sum(total_fleet$fleet_composition)

head(total_fleet)

```

## Detailed fleet data

Alternatively, the user can also pass as an input a `data.frame` with detailed data on  which vehicle categories (age/technology) are assigned to each route on the GTFS feed. Here is an example of how this input looks like.

```{r}
det_fleet <- data.table::data.table(shape_id = unique(poa$shapes$shape_id),
                                    bus_age = c("2010", "2011", "2012", "2013"),
                                    bus_fuel = "Diesel")

head(det_fleet)
```

# Emission factor

Before we estimate emission levels, we need first need to select the emission factors for each pollutant given a combination of fleet characteristics. The emission factors currently available in `gtfs2emis` are from Europe, US, and Brazil, see below. For Europe and the United States, the available emission factors are more rigorous because they also account for vehicle speed.

The `gtfs2emis` package generates emission factors expressed in `g/km` for each trip segment between consecutive pairs of stops. 

## Europe: emission factors for buses

The `ef_europe` function can be used to estimate the emission factors for multiple pollutants considering different types of vehicles and technologies listed in the [EMEP/EEA air pollutant emission inventory guidebook 2019](https://www.eea.europa.eu/themes/air/air-pollution-sources-1/emep-eea-air-pollutant-emission-inventory-guidebook). See documentation for list of options `?ef_europe`. Supported pollutants: CO, NOx, HC, PM, CH4, NMHC, CO2, SO2, Pb, FC , NO, and NO2.

The function works like this:

```{r}
EF_europe <- ef_europe(pollutant = c("CO", "PM10"),
                       speed = poa_gpslines$speed,
                       veh_type = total_fleet$veh_type_euro,
                       tech = "SCR",
                       slope = 0,
                       load = 0.5,
                       euro = total_fleet$euro_stage,
                       fcorr = rnorm(9, 0.5, 0.1))
head(EF_europe, 3)
```

## United States: emission factors for buses

For the United States, the `ef_usa` function estimates emission factors for multiple pollutants considering different types of fuel, speed and fleet age information based on the [California EMission Factor model (EMFAC2017)](https://arb.ca.gov/emfac/). See documentation for list of options `?ef_usa`. Supported pollutants: CO, NOx, Hydrocarbons as TOG (total organic gases), ROG (reactive organic gases), THC, CH4, PM10, PM2.5, SOx, CO2, N2O and CH4.

```{r}
EF_usa <- ef_usa(pollutant = c("CO", "PM10"),
                 calendar_year = "2019",
                 model_year = total_fleet$year,
                 speed = poa_gpslines$speed,
                 fuel = "Diesel")
head(EF_usa, 3)
```

## Brazil: emission factors for buses

For buses in Brazil, the `ef_brazil` functions estimates emission factors considering model year and types of buses. These estimates are based on data from [CETESB 2017](https://cetesb.sp.gov.br/veicular/) obtained via the [`vein` package](https://atmoschem.github.io/vein/). Supported pollutants: CO, HC, NMHC, CH4, NOx, CO2, RCHO, ETOH, PM, N2O, KML, FC, NO2, NO, gD/KWH, gCO2/KWH, RCHO.
, CO_0km, HC_0km, NMHC_0km, NOx_0km, NO2_0km, NO_0km, RCHO_0km, ETOH_0km, and FS (fuel sales).


_Acho que não é necessario mostrar os fatores 0km, pois só usados os deteriorados. Inclusive, os fatores deteriorados só aplicam a veículos com motor Otto ou Flex, então não aplica incluir aqui. FS tambem não, pois é pensado na estimativa de emissões evaporativas desde o veículo ao ambiente ao momento de abastecimento_

```{r}
EF_brazil <- ef_brazil(pollutant = c("CO", "CO2"),
                       veh_type = "BUS_URBAN_D",
                       years = total_fleet$year) # fleet_composition
head(EF_brazil, 3)
```

# Emission 

Now that we have route segment-level information on vehicles, distances, and speeds, emissions levels can be estimated as a product between distances (units `km`), emission factors (units `g/km`) and speed (units `km/h`) in the case of American and European emission factors.

Here is an example using using different emission factors from Europe, USA and Brazil.

```{r}
# USA
emi_usa <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                           dist = poa_gpslines$dist,
                           ef = EF_usa, 
                           prefix = "USA",
                           as_list = TRUE)

# EUROPE
emi_europe <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = poa_gpslines$dist,
                              ef = EF_europe,
                              prefix = "EU",
                              as_list = TRUE)

# BRAZIL (not speed dependent emission factor)
emi_brazil <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = poa_gpslines$dist,
                              ef = EF_brazil,
                              prefix = "BR",
                              as_list = TRUE)
head(emi_brazil, 3)
```
# Analyzing public transport emission levels

To facilitate the analysis of these emissions estimates, the `gtfs2emis` package also includes the `emis_summary` function, a handy function to aggregate results by time at different temporal resolutions. This allows users to examine how the transport emissions of a given public transport network varies over the day.

## Hour time stamp
```{r}
hour_emissions <- gtfs2emis:: emis_summary(emi = emi_europe,
                                           emi_var = "emi", 
                                           by = "time",  # veh_type, time, pollutant 
                                           time_column = poa_gpslines$departure_time, # veh_type
                                           pol_var = "pollutant")
library(ggplot2)
ggplot(data = hour_emissions) + 
  geom_line(aes(x = time, y = as.numeric(CO)/1000), color = 'gray50') +
  xlab("Hour of the day") + ylab("Total CO emitted in Kilograms") +
  theme_bw()
```

## Spatialize
Finally, we can also map how emission levels varies across space and time of the day. To do this, we need first to aggregate our emission estimates on a spatial grid.

The spatial aggregation can be done using any spatial polygons, including hexagonal grids, census tracts etc. In this example we are using some support functions from the `VEIN` package to generate a regular grid.


```{r, message = FALSE, eval = FALSE}
# PEDRO: funcao para escolher a resolucao? esta funcao deveria receber um objeto
# com unidade de medida, para casar com "km"
#
# Create a regular spatial grid
grid_gps <- vein::make_grid(spobj = poa_gpslines$geometry, width =  0.25 / 102.47) # 500 meters
plot(grid_gps["id"])
```

Emissions can be aggregated into the grid with the `emis_grid` function, which sums the total emissions into each single grid cell.

```{r, message = FALSE, eval = FALSE}
# convert estimates to sf spatial object
poa_sf <- sf::st_as_sf(poa_gpslines)
poa_sf$emi_co2_total <- emi_brazil$emi$BR_CO2_total
# spatial aggregation
pol_gps <- emis_grid(data = poa_sf,
                     emi = c("emi_co2_total"),
                     grid = grid_gps)


ggplot() +
  geom_sf(data = pol_gps, aes(fill = as.numeric(emi_co2_total) / 1000), color = NA) +
  scale_fill_viridis_c(option = "plasma") +
  labs(fill = "Daily CO2\nemitted locally\n(g)") +
  theme_bw()
```

User can also display gridded emissions by time and grid cell by specifying `hour` or `hour-minute` in the `time_class` argument. 

```{r, message = FALSE, eval = FALSE}
# # spatial aggregation by hour
pol_gps_hour <- gtfs2emis::emis_grid(data = poa_sf,
                                     emi = c("emi_co2_total"),
                                     grid = grid_gps,
                                     time_class = 'hour',
                                     time_column = 'departure_time')

# subset hours of interest
pol_gps_hour <- subset(pol_gps_hour, time_column %in% c(6,7))
pol_gps_hour$time_column <- as.character(pol_gps_hour$time_column)
to_string <- as_labeller(c(`6` = "Hour 6", `7` = "Hour 7"))
#pol_gps_hour$time_column <- as.character(pol_gps_hour$time_column)

library(ggplot2)                      
ggplot(data = pol_gps_hour) +
  geom_sf(aes(fill=as.numeric(emi_co2_total) / 1000), color = NA) +
  scale_fill_viridis_c(option = "plasma") +
  labs(fill = "Hourly CO\nemitted\n(kg)") +
  facet_wrap(facets = vars(time_column), labeller = to_string) + 
  theme_minimal() +
  theme(axis.text = element_blank(),
        strip.background = element_rect(fill = "gray80", color = NA))

```
