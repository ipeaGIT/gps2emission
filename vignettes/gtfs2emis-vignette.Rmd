---
title: "Introduction to gtfs2emis"
author: "Joao Bazzo, Rafael H. M. Pereira, Pedro R. Andrade"
abstract: Package `gtfs2emis` generates emission estimates for public transport networks based on GTFS data.
output: github_document
urlcolor: blue
vignette: |
%\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{gtfs2emis}
  ---
  24 June 2020
  
```{r, include = FALSE}
  knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
  )
```
  # Introduction
  
  The package `gtfs2emis` estimates hot exhaust emissions for public transport networks at high spatial and temporal resolutions based on GTFS data. This vignette introduces the main functions of the package. Here are the following packages we will use:
  
```{r, message = FALSE}
  library(gtfs2emis)
  library(gtfs2gps)
  library(data.table)
  library(magrittr)
  library(ggplot2)
  library(vein)

```
  
  # GTFS data
  
  To estimate emissions from GTFS data, we need first to compute `speed` and distance (`dist`) ofr each trip between pairs of public transport stops/stations.
  This information is created when we convert GTFS data to GPS-like
  records, using `gtfs2gps::gtfs2gps()`. The example below uses a sample of the GTFS data from SÃ£o Paulo municipality, in Brazil. In this example we will only process the trips of two `shape_id`s to speedup processing time.
  
```{r, message = FALSE}
  # 'spo'
  spo <- gtfs2gps::read_gtfs(system.file("extdata/saopaulo.zip", package = "gtfs2gps")) %>%
  gtfs2gps::filter_by_shape_id(c("51982","50784"))
  spo_gps <- gtfs2gps::gtfs2gps(spo)
  
  # the ouput is a data.table, like this
  head(spo_gps)
  
```
The GPS-like data can be converted into line segments (`linestring`). This conversion breaks the trips into separate segments between consecutive pairs of stops. This will give us a much smaller data set to work on, and allows to capture the spatial-temporal variation of speeds and emissions levels. 
  
  
```{r}
spo_gpslines <- gtfs2gps::gps_as_sflinestring(spo_gps) %>% dplyr::select(speed, dist, departure_time)

dim(spo_gps)
dim(spo_gpslines)

# the bus routes look like this:
plot(spo_gpslines['speed'])


```

We will also update units of measurement of the attributes in our data.

```{r}
spo_gpslines$speed <- units::set_units(spo_gpslines$speed, "km/h")
spo_gpslines$dist <- units::set_units(spo_gpslines$dist, "km")

# The data shows the average speed and distance between pairs of stops
head(spo_gpslines)
```

# Fleet data

To compute emission estimates, we need some basic information on the age and technology of the public transport fleet. The user can input fleet data organized in two different ways. We call them _regional data_ and _detailed data_.

## Regional fleet data

Regional fleet data input is a simple `data.frame` with information on the **relative composition of the fleet in terms of age and technology**. For many cities, this is the only data from registry of vehicles made available by local transport agencies. In this typical situation, there is no information on which vehicles (age and/or technology) are assigned to specific routes in the GTFS. In this case, the package `gtfs2emis` considers that, on average, all vehicles have the same probability to operate on every route of the transport network.
Here is an example of how a _regional fleed data_ looks like:


```{r}
total_fleet <- data.table::data.table(year = c(2005,2010,2011,2012,2014,2015,2017,2018,2019),
                                      bus = c(1,61,50,1,45,18,62,27,31),
                                      veh_type_euro = "Urban Buses Standard 15 - 18 t",
                                      euro_stage = c("II", "IV", "IV", "V", "V", "V", "V", "V","V"))

total_fleet[,fleet_composition := bus/sum(bus)]

# The input data looks like this
head(total_fleet)

```


## Detailed fleet data

Alternatively, the user can also pass as an input a `data.frame` with detailed data on  which vehicle categories (age/technology) are assigned to each route on the GTFS feed. Here is an example of how this input looks like.

```{r}
det_fleet <- data.table::data.table(shape_id = unique(spo$shapes$shape_id),
                                    bus_age = c("2010", "2011", "2012", "2013"),
                                    bus_fuel = "Diesel")

head(det_fleet)
```

# Emission factor

Before we estimate emission levels, we need first need to calculate what are the emission factors for each pollutant given a combination of fleet characteristics. For Europe and the United States, we can use more rigorous functions that also account for speed information as well. The `gtfs2emis` package generates emission factors expressed in `g/km` for each trip segment between consecutive pairs of stops. The emission factors currently available in `gtfs2emis` are from Europe, US, and Brazil, see below.



## European emission factors for buses

The `ef_europe` function can be used to estimate the emission factors for multiple pollutants considering different types of vehicles and technologies listed in the [EMEP/EEA air pollutant emission inventory guidebook 2019](https://www.eea.europa.eu/themes/air/air-pollution-sources-1/emep-eea-air-pollutant-emission-inventory-guidebook). See documentation for list of options `?ef_europe`. Supported pollutants: CO, NOx, HC, PM, CH4, NMHC, CO2, SO2, Pb, FC , NO, and NO2.

The function works like this:

```{r}
EF_europe <- ef_europe(pollutant = c("CO", "PM"),
                       speed = spo_gpslines$speed,
                       veh_type = total_fleet$veh_type_euro,
                       tech = "SCR",
                       euro = total_fleet$euro_stage)
head(EF_europe,3)
```

## United States emission factors for buses

For the United States, the `ef_usa` function estimates emission factors for multiple pollutants considering different types of fuel, speed and fleet age information based on the [California EMission Factor model (EMFAC2017)](https://arb.ca.gov/emfac/). See documentation for list of options `?ef_usa`. Supported pollutants: CO, NOx, Hydrocarbons as TOG (total organic gases), ROG (reactive organic gases), THC, CH4, PM10, PM2.5, SOx, CO2, N2O and CH4.

```{r}
EF_usa <- ef_usa(pollutant = c("CO","PM10"),
                 calendar_year = "2019",
                 model_year = total_fleet$year,
                 speed = spo_gpslines$speed,
                 fuel = "Diesel")
head(EF_usa,3)
```

## Brazil emission factors for buses

For buses in Brazil, the `ef_brazil` functions estimates emission factors considering model year and types of buses. These estimates are based on data from [CETESB 2017](https://cetesb.sp.gov.br/veicular/) obtained via the [`vein` package](https://atmoschem.github.io/vein/). Supported pollutants: CO, HC, NMHC, CH4, NOx, CO2, RCHO, ETOH, PM, N2O, KML, FC, NO2, NO, gD/KWH, gCO2/KWH, RCHO, CO_0km, HC_0km, NMHC_0km, NOx_0km, NO2_0km, NO_0km, RCHO_0km, ETOH_0km, and FS (fuel sales).

```{r}
EF_brazil <- ef_brazil(pollutant = c("CO","CO2"),
                       veh_type = "BUS_URBAN_D",
                       years = total_fleet$year) # fleet_composition
head(EF_brazil, 3)
```


# Emission 

Now that we have route segment-level information on vehicles, distances and emission factors, emissions levels can be estimated as a product between distances (units `km`) and emission factors (units `g/km`). Using the `emis` function we can estimate emissions at high spatial and temporal resolutions.

Here is an example using using different emission factors from Europe, USA and Brazil.

```{r}
# USA
emi_usa <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                           dist = spo_gpslines$dist,
                           ef = EF_usa, prefix = "USA")


# EUROPE
emi_europe <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = spo_gpslines$dist,
                              ef = EF_europe,
                              prefix = "EU")

# BRAZIL (not speed dependent emission factor)
emi_brazil <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = spo_gpslines$dist,
                              ef = EF_brazil,
                              prefix = "BR")
head(emi_brazil, 3)


```

When we join emission estimates with `sf` spatial data, it looks like this.

```{r}
spo_emis <- cbind(spo_gpslines, emi_usa)
spo_emis <- cbind(spo_emis, emi_europe)
spo_emis <- cbind(spo_emis, emi_brazil)

head(spo_emis)

```


# Analyzing public transport emission levels

To facilitate the analysis of these emissions estimates, the `gtfs2emis` package also includes the `emis_post`, a handy function to aggregate results by time at different temporal resolutions. This allows users to examine how the transport emissions of a given public transport network varies over the day.

## Hour time stamp
```{r}
hour_emissions <- gtfs2emis::emis_post(data = spo_emis,
                                  emi = c('BR_CO_total','EU_CO_total'), 
                                  time_class = "hour",
                                  time_column = 'departure_time')

ggplot(data = hour_emissions) + 
    geom_line(aes(x = departure_time, y = as.numeric(BR_CO_total)/1000), color='gray50') +
    geom_line(aes(x = departure_time, y = as.numeric(EU_CO_total)/1000)) +
    xlab("Hour of the day") + ylab("Total CO emitted in Kilograms") +
    theme_bw()

```

## Hour-minute time stamp
Alternatively, the user can aggregate the results at every minute, getting a much higher temporal resolution.

```{r}
minute_emissions <- gtfs2emis::emis_post(data = spo_emis,
                                  emi = c('BR_CO_total','EU_CO_total'),
                                  time_class = "hour-minute",
                                  time_column = 'departure_time')

minute_emissions[,group_x := .GRP, by = departure_time]
breaks <- minute_emissions$group_x[seq(1,nrow(minute_emissions),length.out = 10)]
x_labels <- minute_emissions[breaks,departure_time]

ggplot(data = minute_emissions) +
  geom_line(aes(group = 1, x = group_x, y = as.numeric(BR_CO_total)/1000), color='gray50') +
  geom_line(aes(group = 1, x = group_x, y = as.numeric(EU_CO_total)/1000)) +
  xlab("Time of the day") + ylab("Total CO emitted in Kilograms") +
  scale_x_continuous(breaks = breaks,labels = x_labels) +
  theme_bw()

```

## Spatialize
Finally, we can also map how emission levels varies across space and time of the day. To do this, we need first to aggregate our emission estimates on a spatial grid.

In this example, we are using some support functions from the `VEIN` package, but this aggregation can be done using any spatial polygons, including hexagonal grids, census tracts etc.

```{r}
# PEDRO: funcao para escolher a resolucao? esta funcao deveria receber um objeto
# com unidade de medida, para casar com "km"

# Create a regular spatial grid
grid_gps <- vein::make_grid(spobj = spo_emis, width =  0.25 / 102.47) # 500 meters
plot(grid_gps["id"])
```

Intersect and aggregate data

Emissions can be allocated into grid through emis_grid function, which sums the total emissions into a single grid cell.

```{r}
# convert estimates to sf spatial object
spo_sf <- sf::st_as_sf(spo_emis)

# # spatial aggregation
 pol_gps <- gtfs2emis::emis_grid(data = spo_sf,
                      emi = c("EU_CO_total","BR_CO_total"),
                      grid = grid_gps,
                      time_class = 'all periods')
# 
ggplot() +
  geom_sf(data=pol_gps, aes(fill=as.numeric(EU_CO_total)/1000), color=NA) +
  scale_fill_viridis_c(option = "plasma") +
  labs(fill = "Daily CO\nemitted locally\n(g)") +
  theme_bw()

```

User can also display gridded emissions by time and grid cell by specifying `hour` or `hour-minute` in the `time_class` argument. 
 
 
```{r}
# # spatial aggregation by hour
pol_gps_hour <- gtfs2emis::emis_grid(data = spo_sf,
                      emi = c("EU_CO_total","BR_CO_total"),
                      grid = grid_gps,
                      time_class = 'hour',
                      time_column = 'departure_time')
# changing name for ggplot
pol_gps_hour$time_column <- paste('Hour',pol_gps_hour$time_column)
pol_gps_hour$time_column <- factor(pol_gps_hour$time_column ,paste("Hour",0:23))

ggplot(data = pol_gps_hour) +
  geom_sf(aes(fill=as.numeric(EU_CO_total)/1000), color=NA) +
  scale_fill_viridis_c(option = "plasma") +
  labs(fill = "Daily CO\nemitted locally\n(kg)") +
    theme(panel.background = element_rect(fill = "white", 
      colour = NA), 
      panel.border = element_rect(fill = NA, 
      colour = "grey20"), 
      axis.text.x =  element_text(angle = -90),
      panel.grid = element_line(colour = "grey92"), 
      panel.grid.minor = element_line(size = rel(0.5)), 
      strip.background = element_rect(fill = "grey85", 
        colour = "grey20"), legend.key = element_rect(fill = "white", 
        colour = NA), complete = TRUE) + 
  facet_wrap(facets = vars(time_column))

```
