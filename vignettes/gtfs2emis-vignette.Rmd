---
title: "Introduction to gtfs2emis"
author: "Joao Bazzo, Rafael H. M. Pereira, Pedro R. Andrade"
abstract: Package `gtfs2emis` generates emissions estimates from GTFS data.
output: github_document
urlcolor: blue
vignette: |
%\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{gtfs2emis}
  ---
  02 June 2020
  
```{r, include = FALSE}
  knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
  )
```
  # Introduction
  
  Package `gtfs2emis` estimates hot exhaust emissions from GTFS data. This vignette introduces the main functions of the package. It uses the following packages:
  
```{r, message = FALSE}
  library(gtfs2emis)
  library(vein)
  library(magrittr)
  library(gtfs2gps)
  library(data.table)
  library(magrittr)
  library(ggplot2)
```
  
  # GTFS data
  
  To estimate emissions from GTFS data, first it is necessary to compute `speed` and distance (`dist`) for each trip.
  These information are created when we convert GTFS data to GPS-like
  records, using `gtfs2gps::gtfs2gps()`. The example below uses GTFS data from Porto Alegre municipality, in Brazil. It processes only one `shape_id` in order to speedup processing time.
  
```{r, message = FALSE}
  # 'poa' to 'spo'
  spo <- gtfs2gps::read_gtfs(system.file("extdata/saopaulo.zip", package = "gtfs2gps")) %>%
  gtfs2gps::filter_by_shape_id("51982")
  spo_gps <- gtfs2gps::gtfs2gps(spo)
```
  The GPS-like data can be converted into line segments (`linestring`). This conversion breaks the trips into several segments, each one between two stops.
  
  
```{r}
spo_gpslines <- gtfs2gps::gps_as_sflinestring(spo_gps) %>% dplyr::select(speed, dist, departure_time)

dim(spo_gps)
dim(spo_gpslines)
```

We will also update the two relevant attributes to use units of measurement.

```{r}
spo_gpslines$speed <- units::set_units(spo_gpslines$speed, "km/h")
spo_gpslines$dist <- units::set_units(spo_gpslines$dist, "km")
```

# Fleet data

Computing emissions depend on fleet data, which include age and technology.
There are two types of fleet data to be used for estimating emissions. We call them _regional data_ and _detailed data_.

## Regional data

Data obtained from registry of vehicles in local agencies of transportation generally do not relate a specific route or shape in the GTFS to the respective vehicle category (age and/or technology). 
In this situation, usually only a distribution of fleet is known. In this case, the vehicles of each shape or route must be given from a probability distribution. Package `gtfs2emis` considers that, on average, all vehicles have the same probability to circulate in each route or shape. We need then to create a `data.table` with the content of the fleet.


```{r}
total_fleet <- data.table::data.table(year = c(2005,2010,2011,2012,2014,2015,2017,2018,2019),
                                      bus = c(1,61,50,1,45,18,62,27,31),
                                      veh_type_euro = "Urban Buses Standard 15 - 18 t",
                                      euro_stage = c("II", "IV", "IV", "V", "V", "V", "V", "V","V"))
total_fleet[,fleet_composition := bus/sum(bus)]
```
with probability of distribution based on frequency of `distribution` column.


## Detailed data

Detailed data is used when the category of the vehicle is known for each route or shape of GTFS. The code below shows an example of specific fleet for each bus route.

```{r}
det_fleet <- data.table::data.table(shape_id = unique(spo$shapes$shape_id),
                                    bus_age = c("2010", "2011", "2012", "2013"),
                                    bus_fuel = "Diesel")
```

# Emission factor

Emission factors functions are expressed in `g/km`. They can also be speed-dependent, according to emission factor data source. The avaliable emissions factors available in `gtfs2emis` are from Europe, US, and Brazil.

## European emission factors for buses categories

Supported pollutants are (g/km): CO, NOx, HC, PM, CH4, NMHC, CO2, SO2, Pb, FC , NO, and NO2.

```{r}
EF_europe <- ef_europe(speed = spo_gpslines$speed,
                       veh_type = total_fleet$veh_type_euro, # `total_fleet$veh_type`
                       tech = "SCR",
                       euro = total_fleet$euro_stage,
                       pollutant = c("CO", "PM")) # fleet_composition
head(EF_europe,2)
```

## United States emission factors for buses categories

Supported pollutants are (g/km): CO, NOx, Hydrocarbons as TOG (total organic gases), ROG (reactive organic gases), THC, CH4, PM10, PM2.5, SOx, CO2, N2O and CH4.

```{r}
EF_usa <- ef_usa(pollutant = c("CO","PM10"),
                 calendar_year = "2019",
                 model_year = total_fleet$year,
                 speed = spo_gpslines$speed,
                 fuel = "Diesel")
head(EF_usa,2)
```

## Brazil emission factors for buses

Supported pollutants are (g/km): CO, HC, NMHC, CH4, NOx, CO2, RCHO, ETOH, PM, N2O, KML, FC, NO2, NO, gD/KWH, gCO2/KWH, RCHO, CO_0km, HC_0km, NMHC_0km, NOx_0km, NO2_0km ,NO_0km, RCHO_0km, ETOH_0km, and FS (fuel sales). This data was Obtained from `vein` package.

```{r}
# PEDRO: encapsular isto em uma funcao?
# note que o usuario precisa controlar year e veh_distrib manualmente
EF_brazil <- ef_brazil(pollutant = c("CO","PM"),veh_type = "BUS_URBAN_D", #veh_type
                       years = total_fleet$year) # fleet_composition
head(EF_brazil,2)
```

# Emission 

Emissions are estimated as a product between distance (units `km`) with emission factor (units `g/km`).


## Using different emission factors

```{r}
emi_usa <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                           dist = spo_gpslines$dist,
                           ef = EF_usa)
head(emi_usa,2)
colnames(emi_usa) <- paste0("USA_", colnames(emi_usa))
# cbind
spo_gpslines <- cbind(spo_gpslines, emi_usa)

# EUROPE
emi_europe <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = spo_gpslines$dist,
                              ef = EF_europe,
                              aggregate = TRUE)
colnames(emi_europe) <- paste0("EU_", colnames(emi_europe))
spo_gpslines <- cbind(spo_gpslines, emi_europe)

# BRAZIL (not speed dependent emission factor)
emi_brazil <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = spo_gpslines$dist,
                              ef = EF_brazil)
colnames(emi_brazil) <- paste0("BR_", colnames(emi_brazil))
spo_gpslines <- cbind(spo_gpslines, emi_brazil)
```

# Post-processing emissions

## Hour time stamp
```{r}
hour_post <- gtfs2emis::emis_post(data = spo_gpslines,
                                  emi = c('BR_CO_total','EU_CO_total'), 
                                  time_class = "hour",
                                  time_column = 'departure_time')

ggplot() + 
  geom_bar(data = hour_post, 
           aes(x = departure_time, y = as.numeric(BR_CO_total)),stat = "identity")
```

## Hour-minute time stamp
```{r}
hour_post <- gtfs2emis::emis_post(data = spo_gpslines,
                                  emi = c('BR_CO_total','EU_CO_total'), # check better names
                                  time_class = "hour-minute",
                                  time_column = 'departure_time')

breaks <- hour_post$departure_time[seq(1,nrow(hour_post),length.out = 5)]
ggplot() + 
  geom_bar(data = hour_post, 
           aes(x = departure_time, y = as.numeric(BR_CO_total)),stat = "identity") +
    scale_x_discrete(breaks = breaks)
```

## Spatialize

Make grid to visualize emissions as a map.

```{r}
# PEDRO: funcao para escolher a resolucao? esta funcao deveria receber um objeto
# com unidade de medida, para casar com "km"
grid_gps <- vein::make_grid(spobj = spo_gpslines, width =  0.25 / 102.47) # 500 meters
plot(grid_gps["id"])
```

Intersection operation

```{r}
spo_sf <- sf::st_as_sf(spo_gpslines)
pol_gps <- vein::emis_grid(spobj = spo_sf["EU_CO_total"], g = grid_gps)
pol_gps <- pol_gps[as.numeric(pol_gps$EU_CO_total) > 0, ]
plot(pol_gps["EU_CO_total"])
```
