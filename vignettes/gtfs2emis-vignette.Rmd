---
title: "Introduction to gtfs2emis"
author: "Joao Bazzo, Rafael H. M. Pereira, Pedro R. Andrade"
abstract: Package `gtfs2emis` generates emission estimates for public transport networks based on GTFS data.
output: github_document
urlcolor: blue
vignette: |
%\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{gtfs2emis}
  ---
  24 June 2020
  
```{r, include = FALSE}
  knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
  )
```
  # Introduction
  
  The package `gtfs2emis` estimates hot exhaust emissions for public transport networks at high spatial and temporal resolutions based on GTFS data. This vignette introduces the main functions of the package. Here are the following packages we will use:
  
```{r, message = FALSE}
  library(gtfs2emis)
  library(gtfs2gps)
  library(data.table)
  library(magrittr)
  library(ggplot2)
  library(vein)

```
  
  # GTFS data
  
  To estimate emissions from GTFS data, we need first to compute `speed` and distance (`dist`) ofr each trip between pairs of public transport stops/stations.
  This information is created when we convert GTFS data to GPS-like
  records, using `gtfs2gps::gtfs2gps()`. The example below uses a sample of the GTFS data from SÃ£o Paulo municipality, in Brazil. In this example we will only process the trips of one `shape_id` to speedup processing time.
  
```{r, message = FALSE}
  # 'poa' to 'spo'
  spo <- gtfs2gps::read_gtfs(system.file("extdata/saopaulo.zip", package = "gtfs2gps")) %>%
  gtfs2gps::filter_by_shape_id("51982")
  spo_gps <- gtfs2gps::gtfs2gps(spo)
  
  # the ouput is a data.table, like this
  head(spo_gps)
  
```
  The GPS-like data can be converted into line segments (`linestring`). This conversion breaks the trips into several segments between consecutive pairs of stops. This will give us a much smaller data set to work on, and allows to capture the spatial-temporal variation of emissions levels. 
  
  
```{r}
spo_gpslines <- gtfs2gps::gps_as_sflinestring(spo_gps) %>% dplyr::select(speed, dist, departure_time)

dim(spo_gps)
dim(spo_gpslines)

```

We will also update units of measurement of the attributes in our data.

```{r}
spo_gpslines$speed <- units::set_units(spo_gpslines$speed, "km/h")
spo_gpslines$dist <- units::set_units(spo_gpslines$dist, "km")

# The data shows the average speed and distance between pairs of stops
head(spo_gpslines)
```

# Fleet data

To compute emission estimates, we need some basic information on the age and technology of the public transport fleet. The user can input fleet data organized in two different ways. We call them _regional data_ and _detailed data_.

## Regional fleet data

Regional fleet data input is a simple `data.frame` with information on the **relative composition of the fleet in terms of age and technology**. For many cities, this is the only data from registry of vehicles made available by local transport agencies. In this typical situation, there is no information on which vehicles (age and/or technology) are assigned to specific routes in the GTFS. In this case, the package `gtfs2emis` considers that, on average, all vehicles have the same probability to operate on every route of the transport network.
Here is an example of how a _regional fleed data_ looks like:


```{r}
total_fleet <- data.table::data.table(year = c(2005,2010,2011,2012,2014,2015,2017,2018,2019),
                                      bus = c(1,61,50,1,45,18,62,27,31),
                                      veh_type_euro = "Urban Buses Standard 15 - 18 t",
                                      euro_stage = c("II", "IV", "IV", "V", "V", "V", "V", "V","V"))

total_fleet[,fleet_composition := bus/sum(bus)]

# The input data looks like this
head(total_fleet)

```


## Detailed fleet data

Alternatively, the user can also pass as an input a `data.frame` with detailed data on  which vehicle categories (age/technology) are assigned to each route on the GTFS feed. Here is an example of how this input looks like.

```{r}
det_fleet <- data.table::data.table(shape_id = unique(spo$shapes$shape_id),
                                    bus_age = c("2010", "2011", "2012", "2013"),
                                    bus_fuel = "Diesel")

head(det_fleet)
```

# Emission factor

Before we estimate emission levels, we need first need to calculate what are the emission factors for each pollutant given our fleet characteristics. For some regions, we can use more rigorous emission factor functions that also account for speed information. The emission factors currently available in `gtfs2emis` are from Europe, US, and Brazil, and they are expressed in `g/km` (see below).


## European emission factors for bus categories

Supported pollutants are: CO, NOx, HC, PM, CH4, NMHC, CO2, SO2, Pb, FC , NO, and NO2. The `ef_europe` function can be used to estimate the emission factors for multiple pollutants considering different types of vehicles and technologies listed in the [EMEP/EEA air pollutant emission inventory guidebook 2019](https://www.eea.europa.eu/themes/air/air-pollution-sources-1/emep-eea-air-pollutant-emission-inventory-guidebook). See documentation for list of options. The function will generate the emission factors for trip segment between consecutive pairs of stops, and it works like this:

```{r}
EF_europe <- ef_europe(speed = spo_gpslines$speed,
                       veh_type = total_fleet$veh_type_euro, # `total_fleet$veh_type`
                       tech = "SCR",
                       euro = total_fleet$euro_stage,
                       pollutant = c("CO", "PM")) # fleet_composition
head(EF_europe,2)
```

## United States emission factors for buses categories

Supported pollutants are (g/km): CO, NOx, Hydrocarbons as TOG (total organic gases), ROG (reactive organic gases), THC, CH4, PM10, PM2.5, SOx, CO2, N2O and CH4.

```{r}
EF_usa <- ef_usa(pollutant = c("CO","PM10"),
                 calendar_year = "2019",
                 model_year = total_fleet$year,
                 speed = spo_gpslines$speed,
                 fuel = "Diesel")
head(EF_usa,2)
```

## Brazil emission factors for buses

Supported pollutants are (g/km): CO, HC, NMHC, CH4, NOx, CO2, RCHO, ETOH, PM, N2O, KML, FC, NO2, NO, gD/KWH, gCO2/KWH, RCHO, CO_0km, HC_0km, NMHC_0km, NOx_0km, NO2_0km ,NO_0km, RCHO_0km, ETOH_0km, and FS (fuel sales). This data was Obtained from `vein` package.

```{r}
# PEDRO: encapsular isto em uma funcao?
# note que o usuario precisa controlar year e veh_distrib manualmente
EF_brazil <- ef_brazil(pollutant = c("CO","PM"),
                       veh_type = "BUS_URBAN_D",
                       years = total_fleet$year) # fleet_composition
head(EF_brazil,2)
```

# Emission 




The next step is to combine and route-level information on speed and distances and information on fleet characteristics to

Emissions are estimated as a product between distance (units `km`) with emission factor (units `g/km`).


## Using different emission factors

```{r}
emi_usa <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                           dist = spo_gpslines$dist,
                           ef = EF_usa)
head(emi_usa,2)
colnames(emi_usa) <- paste0("USA_", colnames(emi_usa))
# cbind
spo_gpslines <- cbind(spo_gpslines, emi_usa)

# EUROPE
emi_europe <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = spo_gpslines$dist,
                              ef = EF_europe,
                              aggregate = TRUE)
colnames(emi_europe) <- paste0("EU_", colnames(emi_europe))
spo_gpslines <- cbind(spo_gpslines, emi_europe)

# BRAZIL (not speed dependent emission factor)
emi_brazil <- gtfs2emis::emis(fleet_composition = total_fleet$fleet_composition,
                              dist = spo_gpslines$dist,
                              ef = EF_brazil)
colnames(emi_brazil) <- paste0("BR_", colnames(emi_brazil))
spo_gpslines <- cbind(spo_gpslines, emi_brazil)
```

# Post-processing emissions

## Hour time stamp
```{r}
hour_post <- gtfs2emis::emis_post(data = spo_gpslines,
                                  emi = c('BR_CO_total','EU_CO_total'), 
                                  time_class = "hour",
                                  time_column = 'departure_time')

ggplot() + 
  geom_bar(data = hour_post, 
           aes(x = departure_time, y = as.numeric(BR_CO_total)),stat = "identity")
```

## Hour-minute time stamp
```{r}
hour_post <- gtfs2emis::emis_post(data = spo_gpslines,
                                  emi = c('BR_CO_total','EU_CO_total'), # check better names
                                  time_class = "hour-minute",
                                  time_column = 'departure_time')

breaks <- hour_post$departure_time[seq(1,nrow(hour_post),length.out = 5)]
ggplot() + 
  geom_bar(data = hour_post, 
           aes(x = departure_time, y = as.numeric(BR_CO_total)),stat = "identity") +
    scale_x_discrete(breaks = breaks)
```

## Spatialize

Make grid to visualize emissions as a map.

```{r}
# PEDRO: funcao para escolher a resolucao? esta funcao deveria receber um objeto
# com unidade de medida, para casar com "km"
grid_gps <- vein::make_grid(spobj = spo_gpslines, width =  0.25 / 102.47) # 500 meters
plot(grid_gps["id"])
```

Intersection operation

```{r}
spo_sf <- sf::st_as_sf(spo_gpslines)
pol_gps <- vein::emis_grid(spobj = spo_sf["EU_CO_total"], g = grid_gps)
pol_gps <- pol_gps[as.numeric(pol_gps$EU_CO_total) > 0, ]
plot(pol_gps["EU_CO_total"])
```
